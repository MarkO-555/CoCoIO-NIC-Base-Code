<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>DWise1's Sample Network Applications with Source Code</title>

<meta name="Author" content="David C. Wise">

</head>
<body bgcolor="#ffffe0">
<h1>
<center>
<b> DWise1's Sockets Programming Pages</b>
<p>
Sample Network Applications with Source Code
</p></center>
</h1>
<hr>
<center>               
<font size="+2"><b> HARD HAT AREA<br>
<img src="DWise1's%20Sample%20Network%20Applications%20with%20Source%20Code_files/Bauarbeiter.gif"><br>
WATCH YOUR STEP
</b>
</font>
</center>
<hr>
<h3>Introduction</h3>
<blockquote>
In studying sockets programming, I've written a handful of short programs as learning tools, 
as test-beds, and as utilities.  
So I've started to clean up that code and to comment it properly in preparation to post it on this page.
That way, you will have sample code that may help you as you learn sockets programming.
<p>
I've started with six short simple example programs that implement the three basic types of 
client/server application that I discussed on my 
<a href="http://dwise1.net/pgm/sockets/basic_apps.html">Basic Application Structure</a> web page.
And I'll add on more programs as I get around to cleaning up their source code and
applying meaningful comments that will help you make sense of what I'm doing there.
The links for downloading the source code are listed at the end of this page.
</p><p>
I am writing these sample programs so that they could be compiled either under Windows or under UNIX/Linux.
I've provided <a href="http://dwise1.net/pgm/sockets/INST">General Instructions</a> for compiling them on either system.
</p><p>
These are also all command-line applications (AKA "console apps").
While I haven't yet explored the Windows programming aspect of Winsock (ie, its WSA* functions
that extend sockets to do Windows messaging), when and if I do then I will treat those sample
programs in much the same say that I'll treat samples in other programming languages.
Again, don't expect this any time soon.
</p><p>
I will add more applications to this page in the future.
</p><p>
And I plan to expand my site in the future to include sockets 
programming in other languages, such as Java and perl -- actually, my 
very first study of sockets programming was in perl with Lincoln Stein's
 book, "<a href="http://dwise1.net/pgm/sockets/resources.html#STEIN">Network Programming with Perl</a>".
When that happens (and it will by no means be any time soon), 
I will either add a section on this page for those sample programs or else
create a new page for them.
</p><p>
Please keep in mind that these programs are for educational purposes only and are not meant for
commercial use.
As such, you will use them at your own risk and will not be able to hold me responsible for any
damage they might cause, either directly or indirectly.
Before you download any code, please be sure to read the <a href="#DISCLAIMER">disclaimer</a> in the very next section.
</p></blockquote>
<hr>
<a name="DISCLAIMER">
<h3>Disclaimer</h3>
</a><blockquote><a name="DISCLAIMER">
The examples I present on these web pages are slightly modified versions of example programs from 
<cite></cite></a><a href="http://dwise1.net/pgm/sockets/resources.html#POCKET_GUIDE">The Pocket Guide to TCP/IP Sockets: C Version</a> 
by Michael J. Donahoo and Kenneth L. Calvert 
(second edition title: <cite>TCP/IP Sockets in C: Practical Guide for Programmers</cite>).
I recommend this book highly as a concise quick-start guide to beginning TCP/IP sockets programming.
The original UNIX source code is freely available from their web site at 
<a href="http://cs.baylor.edu/~donahoo/PocketSocket/textcode.html">
http://cs.baylor.edu/~donahoo/PocketSocket/textcode.html</a>
and the Winsock version of the code at 
<a href="http://cs.baylor.edu/~donahoo/PocketSocket/winsock.html">
http://cs.baylor.edu/~donahoo/PocketSocket/winsock.html</a>.
The second-edition website is at <a href="http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/">
http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/</a>.
You should check out both sites, since not all of the links are 
duplicated between them and some of the source code may have changed in 
the second edition.
<p>
On their book's web site, Michael J. Donahoo and Kenneth L. Calvert have posted <a href="http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/textcode.html">their disclaimer</a>, which states:
</p><blockquote>
<table cellpadding="6" bgcolor="#dadAa0">
<tbody><tr><td><b>
"The purpose of this book is to provide general information about 
network programming as of the book's publication date.
The authors have included sample code that is intended for the sole 
purpose of illustrating the use of the sockets API.
Neither the authors nor the publisher are aware of any third party 
patents or proprietary rights that may cover any sample of any kind. 
The authors and the Publisher DISCLAIM ALL EXPRESS AND IMPLIED 
WARRANTIES, including warranties of merchantability and fitness for any 
particular purpose. 
Your use or reliance upon any sample code or other information in this 
book will be at your own risk. 
No one should use any sample code (or illustrations) from this book in 
any software application without first obtaining competent legal 
advice."</b>
</td>
</tr></tbody></table>
</blockquote>
To that, I add <b>my own disclaimer</b>:
<ul>
<li>I am making fair use of Donahoo and Calvert's examples:
<ul>
<li>I cite them and their book as the source of the basis of my examples and give them full credit for their code.
At no time do I attempt to claim their work as my own.
</li><li>I link my readers directly back to their original source code.
</li><li>They make their example source code freely available.
</li><li>I receive absolutely no financial benefit through my use of their examples on my web site.
</li></ul>
</li><li>Since my examples are derived from Donahoo and Calvert's 
examples, their disclaimer is applicable for their parts of my examples 
and must be considered.
</li><li>The sole purpose of my examples is educational.  
I had written and posted them with the sole intention of illustrating how basic TCP/IP applications would be written.
</li><li><b>My examples were never intended to be production-quality applications.</b>
</li><li><b>You use my examples <i>completely at your own risk</i>.
Although I have tested the programs, <i>I disclaim any responsibility or liability for any loss or damage that may occur as a result of using my examples</i>.</b>
</li><li>If you do distribute or use my examples, with or without your 
own modifications, you must annotate the source for that code, namely 
Donahoo and Calvert and myself.
</li></ul>
</blockquote>
<hr>
<h3><a name="INST">General Instructions</a></h3>
<blockquote>
<dl>
<dt><h4>Windows</h4></dt>
<dd>
<ol>
<li>Download the ZIP file containing the source files you're interested in.
<p>
</p></li><li>Extract the source files with WinZIP or whatever utility you use for ZIP files.
It appears that under Windows XP, the Windows Explorer utility can open ZIP files and extract files from them.
<p>
</p></li><li>The source files are ready to be compiled under Windows:
<ul>
<li>The WINSOCK_EXAMPLE manifest has been defined (<code>#define WINSOCK_EXAMPLE</code>).
<p>
</p></li><li>The files are DOS-style text files (newline == CRLF).
<p>
</p></li><li>If you use Visual C++, then create an empty console application, add the source file to it, and link <code>WS2_32.LIB</code> into the project.
For more detailed instructions, read 
<a href="http://cs.baylor.edu/~donahoo/practical/CSockets/WindowsSockets.pdf">Transitioning from UNIX to Windows Socket Programming</a> by Paul O'Steen.
<p>
</p></li><li>If you use a port of gcc that supports sockets, 
such as <a href="http://www.mingw.org/">MinGW</a> (distributed with <a href="http://www.bloodshed.net/">Dev-C++</a>), 
then link in the libws2_32.a library or whatever it's called in your port; eg:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>gcc -o tcpserver tcpserver.c -lws2_32</code>
<p>
</p></li><li>If you use a different development environment, then do 
whatever is required to create a console application that uses one of my
 source files as the only source and that links in whatever Winsock2 
static library that development environment provides.
Sorry, I can't help you there.  
You've got to work out those details yourself.
</li></ul>
<p>
</p></li><li>Run the application from the command line.
</li></ol>
<p>
</p></dd>
<p>
</p><hr width="50%">
<p>
</p><dt><h4>UNIX/Linux</h4></dt>
<dd>
<ol>
<li>Download the tarball containing the source files you're interested in.
<p>
</p></li><li>Extract the file with the <code>tar</code> utility; eg:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>tar xvfz basic_apps.tar.gz</code>
<p>
</p></li><li>The source files are ready to be compiled:
<ul>
<li>The WINSOCK_EXAMPLE manifest has been undefined (<code>#undef WINSOCK_EXAMPLE</code>).
<p>
</p></li><li>The files are UNIX-style text files (newline == LF).
<p>
</p></li><li>Compile the programs.  Under Linux, you do not need to link in any extra libraries; eg:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>gcc -o tcp_server tcp_server.c</code>
</li></ul>
<p>
</p></li><li>Run the application from the command line.
</li></ol>
</dd>
</dl>
</blockquote>
<hr>
<a name="LINKS">
<h3>Links to the Source Code</h3>
</a><blockquote><a name="LINKS">
While I've tried to make the following samples compilable under both Windows and Linux, since I mainly work in Windows
and since some of what I'm doing (eg, multitasking) will be specific to Windows, I won't always have a Linux version.
I apologize for that in advance.
Though you should still be able to read the code and to modify it for Linux.

The links follow:
</a><blockquote><a name="LINKS">
</a><a name="ECHO">
</a><dl><a name="ECHO">
<dt><h4><li>Basic TCP and UDP echo servers and clients</li></h4></dt>
<p>
</p></a><dd><a name="ECHO">
I wrote these short simple example programs to demonstrate how to implement the basic types of 
TCP and UDP client/server applications that I have discussed on my 
</a><a href="http://dwise1.net/pgm/sockets/basic_apps.html">Basic Application Structure</a>
 web page.
Each program is a contained within a single source file.
Although the programs were written in C, you should still be able to 
apply the principles of the code to whatever language you're working in.
<p>
These implement the echo service, which is a simple network test in which the server simply echos back
to the client everything that the client sends to it.
The echo service is described in <a href="http://www.faqs.org/rfcs/rfc862.html">RFC 862</a>, one of the short ones.
</p><p>
</p></dd>
<p>
<a name="BROADCAST_TIME">
</a></p><dt><h4><li><a name="BROADCAST_TIME">Broadcast time server and client</a></li></h4></dt><a name="BROADCAST_TIME">
<p>
</p></a><dd><a name="BROADCAST_TIME">
I wrote these short simple example programs to demonstrate how to implement the broadcast
client/server model.
</a><p><a name="BROADCAST_TIME">
This client/server application implements the UDP form of the daytime protocol, 
</a><a href="http://www.faqs.org/rfcs/rfc867.html">RFC 867</a>, in that the client 
listens for the server to broadcast the time, which the client then prints out to stdout.
</p><p>
</p></dd>
<p>
</p><li>Both the echo and the broadcast time servers and clients are distributed together in the same archive files:
<ul>
<p>
</p><li><a href="http://dwise1.net/pgm/sockets/echo_apps.ZIP">Windows</a>
<p>
</p></li><li><a href="http://dwise1.net/pgm/sockets/echo_apps.tar.gz">UNIX/Linux</a>
</li></ul>
<p>
</p><hr align="LEFT" width="50%">
<p>
<a name="ECHO_SERVERS">
</a></p><dt><h4><li><a name="ECHO_SERVERS">Multi-client TCP and UDP echo servers</a></li></h4></dt><a name="ECHO_SERVERS">
<p>
</p></a><dd><a name="ECHO_SERVERS">
These are the next phase of echo servers.
These clients and servers establish extended sessions in which the 
client can send several strings to be echoed back by the server.
The servers can also handle multiple clients, arbitrarily limited to 9.
And the TCP servers and clients implement the </a><a href="http://dwise1.net/pgm/sockets/tcp_ip.html#SHUTDOWN">Graceful Shutdown</a>.
<p>
The servers handle multiple clients in different ways as described on my page, 
<a href="http://dwise1.net/pgm/sockets/blocking.html">Dealing With and Getting Around Blocking Sockets</a>:
</p><ol type="1">
<li><cite>echod</cite> uses the <code>select()</code> function as described <a href="http://dwise1.net/pgm/sockets/blocking.html#SELECT">here</a>.
<p>
</p></li><li><cite>echonbd</cite> uses non-blocking sockets as described <a href="http://dwise1.net/pgm/sockets/blocking.html#NONBLOCK">here</a>.
<p>
</p></li><li><cite>echomtd</cite> uses multithreading as described <a href="http://dwise1.net/pgm/sockets/blocking.html#THREADS">here</a>.
However, it uses Windows multithreading instead of Linux' pthreads, but 
if you're experienced with pthreads you shouldn't have much of a problem
 converting it.
<p>
The main thread initializes everything, starts the AcceptThread, and 
then sits back and waits for the keyboard signal to terminate.  
The AcceptThread would just sit there blocked by its <code>accept()</code>
 call until a client would connect, whereupon it would create a 
ClientThread for that client and then go back to being blocked by <code>accept()</code>.
The ClientTread conducts the session with that client, as the other 
ClientThreads do concurrently with the other clients, and when the 
client disconnects then the ClientThread shuts down the connection, 
updates the server's client data, and then terminates; again, the 
ClientThread sits there blocked by its <code>recv()</code> until the client sends it something (which includes notification from the client that it's disconnecting).
</p><p>
In a second iteration, I moved all printf's to a 
<a href="http://en.wikipedia.org/wiki/Critical_section">critical section</a>, a synchronization mechanism to restrict access to a shared resource, which had the effect of forcing some of the thread.
</p><p>
</p></li><li><cite>echoudpd</cite> is <a href="http://dwise1.net/pgm/sockets/blocking.html#UDP">that experiment I considered</a>
 in which I wanted to see whether a simple UDP server wouldn't be able 
to handle multiple clients as-is.
So I took the UDP echo server from above, just as it is, and modified 
the client to bombard it constantly with a fixed message and keep track 
of how many dropped messages and other errors it detected.
20 clients hammered away to the server.  Each and every one of them 
reported no dropped messages and no errors.
</li></ol>
<p>
In order to stress-test the servers, I modified the clients to include a <b><i>-r</i></b> option.
In normal operation, the client prompts you to enter a string to be echoed, which happens when you press enter.
But if you choose option <b><i>-r</i></b>, then the client will blast the server repeatedly with that old standard 70-character typing exercise:
</p><blockquote>
<i>Now is the time for all good men to come to the aid of their country.</i>
</blockquote>
Then have all 9 clients doing the same thing at the same time.
I was surprised to see that the servers could keep up and continue to service all the clients. 
<p>
Again, each program is a contained within a single C source file.
</p><p>
</p><blockquote>
<li><a href="http://dwise1.net/pgm/sockets/echo_servers.ZIP">Windows</a>
</li></blockquote>
<p>
</p><hr align="LEFT" width="50%">
<p>
<a name="UDPTIMEC">
</a></p></dd><dt><h4><li><a name="UDPTIMEC">UDPTimeC time client</a></li></h4></dt><a name="UDPTIMEC">
<p>
</p></a><dd><a name="UDPTIMEC">
I wrote this utility when we were working on a Network Time Protocol (NTP) application.
It's just the UDP time client which requests the time from a server and displays the 
data it receives on the stdout output.
It supports both NTP (</a><a href="http://www.faqs.org/rfcs/rfc2030.html">RFC 2030</a>) and the time service (AKA "timserver", on port 37, <a href="http://www.faqs.org/rfcs/rfc868.html">RFC 868</a>).
<p>
One of its interesting features, pedagoguically speaking, is how it inserts and extracts
binary data into and out of a packet.
This is one of the stumbling blocks for novices and a common question that gets raised.
RFC 2030 specificies an exact format for an NTP data packet, which I follow in this program.
I use this format as an example in my <a href="http://dwise1.net/pgm/sockets/data.html#EXAMPLE">Formatting Packet Data</a> page.
</p><p>
There is a plethora of NTP servers out there 
(refer to <a href="http://support.ntp.org/bin/view/Servers/WebHome">this site</a>
 for a list),
but it's hard to find any time servers.
So that you can test the time protocol features of UDPTIMEC, this 
download also includes a time server (port 37), UDPTIMED, which will 
function either as a regular time server or as a broadcast server,
though only supporting UDP, not TCP, as the name implies.
</p><p>
You can also misuse UDPTIMEC to view hex dumps of responses from other servers.  
For example, I enabled the daytime service (port 13,
<a href="http://tools.ietf.org/html/rfc867">RFC 867</a>) and the "Quote of the day" service 
(AKA "qtod" or "quote", port 17,
<a href="http://tools.ietf.org/html/rfc865">RFC 865</a>) on my XP box and then used UDPTIMEC to query them both:
</p><blockquote>
<table cellpadding="4" bgcolor="#dadAa0">
<tbody><tr><td>
<pre>C:&gt;udptimec localhost 13
Sending 0-byte query to localhost:daytime [127.0.0.1:13]
Received 21 bytes from localhost [127.0.0.1:13]
39 3A 31 33 3A 35 30 20 41 4D 20 31 2F 31 37 2F    9:13:50 AM 1/17/
32 30 30 38 0A                                     2008.
 **********

C:&gt;udptimec localhost 17
Sending 0-byte query to localhost:qotd [127.0.0.1:17]
Received 107 bytes from localhost [127.0.0.1:17]
22 57 65 20 77 61 6E 74 20 61 20 66 65 77 20 6D    "We want a few m
61 64 20 70 65 6F 70 6C 65 20 6E 6F 77 2E 20 53    ad people now. S
65 65 20 77 68 65 72 65 20 74 68 65 20 73 61 6E    ee where the san
65 20 6F 6E 65 73 20 68 61 76 65 20 6C 61 6E 64    e ones have land
65 64 20 75 73 21 22 0D 0A 20 47 65 6F 72 67 65    ed us!".. George
20 42 65 72 6E 61 72 64 20 53 68 61 77 20 28 31     Bernard Shaw (1
38 35 36 2D 31 39 35 30 29 0D 0A                   856-1950)..
 **********
</pre>
</td></tr>
</tbody></table>
</blockquote>
<p>
Of course, you could also query these text-based services with telnet, but you wouldn't get a hex dump.
</p><p>
I'm only providing the Windows version of these programs.
UDPTIMEC is not portable as it stands, because it uses conio in one 
function.
However, my standard conditional compilation macros are in place and I 
clearly indicate which function will need to be changed, so you should 
be able to port it to UNIX/Linux with minimal effort.
</p><p>
The ZIP file below contains both source code and Win32 executable files for both UDPTimeC and UDPTimeD.
</p><p>
</p><ul>
<li><a href="http://dwise1.net/pgm/sockets/UDPtime.zip">Windows</a>
</li></ul>
</dd>
<p>
</p><hr align="LEFT" width="50%">
<p>
<a name="TFTP_CLIENT">
</a></p><dt><h4><li><a name="TFTP_CLIENT">Trivial FTP (tftp) client</a></li></h4></dt><a name="TFTP_CLIENT">
<p>
</p></a><dd><a name="TFTP_CLIENT">
TFTP is a simple file transfer protocol that's described in 
</a><a href="http://www.faqs.org/rfcs/rfc1350.html">RFC 1350</a>.
It accomplishes the basic function of FTP (<a href="http://www.faqs.org/rfcs/rfc959.html">RFC 959</a>), 
only without any need to log in and authenticate and without the commands for directory navigation and listing
and for working with multiple files.
It just gets or puts a single file, quick and dirty and presenting a gaping security hole.
<p>
The source code still needs more clean-up and commenting.
Plus, I'd like to also develop a TFTP server before I post this.
That server will be the first one in which I will plan for servicing multiple clients all at 
the same time.
<!-- UL>
<P>
<LI><A HREF="basic_apps.ZIP">Windows</A>
<P>
<LI><A HREF="basic_apps.tar.gz">UNIX/Linux</A>
</UL -->
</p></dd>
<p>
</p><hr align="LEFT" width="50%">
<p>
<a name="MIM">
</a></p><dt><h4><li><a name="MIM">MiM ("Man in the Middle")</a></li></h4></dt><a name="MIM">
<p>
</p></a><dd><a name="MIM">
This was my very first network program in C.
Anticipating the need to write an embedded telnet client in a Windows test utility 
(that project got farmed out instead), I started studying that protocol.
Needless to say, I was confused about the client/server negotiations and how a client was 
supposed to conduct that negotiation.
So, inspired by the general idea behind "man in the middle" attacks, I wrote as MiM which served 
as a proxy between a telnet server on my Linux box and client on my Windows box, which is also where MiM ran.
The client would connect to it and it would connect to the server and then pass all the messages
back and forth between the client and the server.
At the same time, it wrote all that message traffic to a disk file, in binary so that I could see all
the command bytes, which I would translate to a readable printout with a second utility, MUNG, that I wrote quick-and-dirty.
<p>
This ZIP file contains the source files, mim.c and mung.c, and executables built from them with MinGW gcc.
</p><p>
</p></a><ul><a name="MIM">
<p>
</p></a><li><a name="MIM"></a><a href="http://dwise1.net/pgm/sockets/MiM.ZIP">Windows</a>
<p>
</p></li></ul>
</dd>
</li></dl>
</blockquote>
<p>
</p><hr>
<blockquote>
<a href="#TopOfPage">Return to Top of Page</a><br>
<a href="http://dwise1.net/pgm/sockets/index.html">Return to DWise1's Sockets Programming Page</a><br>
<a href="http://dwise1.net/pgm/index.html">Return to DWise1's Programming Page</a><br>
<p>
<a href="http://dwise1.net/pgm/index.html#CONTACTME">Contact me.</a>
</p></blockquote>
<hr>
<p>
<b><i>Share and enjoy!</i></b>
</p><p>
<i>First uploaded on 2007 January 06.<br>
Updated on 2011 September 10.</i>
</p><p>


</p></blockquote></body></html>